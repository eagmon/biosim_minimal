"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.updateConfigFiles = void 0;
const tslib_1 = require("tslib");
const devkit_1 = require("@nrwl/devkit");
const cli_config_utils_1 = require("@nrwl/workspace/src/utils/cli-config-utils");
const test_runners_1 = require("../../../utils/test-runners");
const create_ts_config_1 = require("../../utils/create-ts-config");
const typescript_1 = require("@nrwl/workspace/src/utilities/typescript");
function updateConfigFiles(host, options) {
    updateTsConfigOptions(host, options);
    updateAppAndE2EProjectConfigurations(host, options);
}
exports.updateConfigFiles = updateConfigFiles;
function updateTsConfigOptions(host, options) {
    // tsconfig.app.json
    (0, devkit_1.updateJson)(host, `${options.appProjectRoot}/tsconfig.app.json`, (json) => (Object.assign(Object.assign({}, json), { extends: './tsconfig.json', compilerOptions: Object.assign(Object.assign({}, json.compilerOptions), { outDir: `${(0, devkit_1.offsetFromRoot)(options.appProjectRoot)}dist/out-tsc` }), exclude: [
            ...new Set([
                ...(json.exclude || []),
                'jest.config.ts',
                'src/**/*.test.ts',
                'src/**/*.spec.ts',
            ]),
        ] })));
    // tsconfig.json
    (0, create_ts_config_1.createTsConfig)(host, options.appProjectRoot, 'app', options, (0, typescript_1.getRelativePathToRootTsConfig)(host, options.appProjectRoot));
}
function updateAppAndE2EProjectConfigurations(host, options) {
    let project = (0, devkit_1.readProjectConfiguration)(host, options.name);
    if (options.ngCliSchematicAppRoot !== options.appProjectRoot) {
        project = (0, cli_config_utils_1.replaceAppNameWithPath)(project, options.ngCliSchematicAppRoot, options.appProjectRoot);
        // project already has the right root, but the above function, makes it incorrect.
        // This corrects it.
        project.root = options.appProjectRoot;
    }
    delete project.targets.test;
    // Ensure the outputs property comes after the executor for
    // better readability.
    const _a = project.targets.build, { executor } = _a, rest = tslib_1.__rest(_a, ["executor"]);
    project.targets.build = Object.assign(Object.assign({ executor, outputs: ['{options.outputPath}'] }, rest), { options: Object.assign(Object.assign({}, rest.options), { outputPath: (0, devkit_1.joinPathFragments)('dist', !options.rootProject ? options.appProjectRoot : options.name) }) });
    if (project.generators) {
        delete project.generators;
    }
    if (options.port) {
        project.targets.serve = Object.assign(Object.assign({}, project.targets.serve), { options: Object.assign(Object.assign({}, project.targets.serve.options), { port: options.port }) });
    }
    project.tags = options.parsedTags;
    /**
     * The "$schema" property on our configuration files is only added when the
     * project configuration is added and not when updating it. It's done this
     * way to avoid re-adding "$schema" when updating a project configuration
     * and that property was intentionally removed by the devs.
     *
     * Since the project gets created by the Angular application schematic,
     * the "$schema" property is not added, so we remove the project and add
     * it back to workaround that.
     */
    (0, devkit_1.removeProjectConfiguration)(host, options.name);
    (0, devkit_1.addProjectConfiguration)(host, options.name, project);
    if (options.unitTestRunner === test_runners_1.UnitTestRunner.None) {
        host.delete(`${options.appProjectRoot}/src/app/app.component.spec.ts`);
        host.delete(`${options.appProjectRoot}/tsconfig.spec.json`);
    }
    if (options.e2eTestRunner === test_runners_1.E2eTestRunner.None) {
        const projects = (0, devkit_1.getProjects)(host);
        if (projects.has(options.e2eProjectName)) {
            (0, devkit_1.removeProjectConfiguration)(host, options.e2eProjectName);
        }
    }
}
//# sourceMappingURL=update-config-files.js.map