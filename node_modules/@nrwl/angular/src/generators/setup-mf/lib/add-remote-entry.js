"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.addRemoteEntry = void 0;
const devkit_1 = require("@nrwl/devkit");
const route_utils_1 = require("../../../utils/nx-devkit/route-utils");
function addRemoteEntry(tree, { appName, routing, mfType, prefix, standalone }, appRoot) {
    var _a, _b;
    prefix =
        (_b = prefix !== null && prefix !== void 0 ? prefix : (_a = (0, devkit_1.readProjectConfiguration)(tree, appName)) === null || _a === void 0 ? void 0 : _a.prefix) !== null && _b !== void 0 ? _b : (0, devkit_1.readNxJson)(tree).npmScope;
    (0, devkit_1.generateFiles)(tree, standalone
        ? (0, devkit_1.joinPathFragments)(__dirname, '../files/standalone-entry-component-files')
        : (0, devkit_1.joinPathFragments)(__dirname, '../files/entry-module-files'), `${appRoot}/src/app/remote-entry`, {
        tmpl: '',
        appName,
        routing,
        prefix,
    });
    if (standalone && routing) {
        (0, route_utils_1.addRoute)(tree, (0, devkit_1.joinPathFragments)(appRoot, 'src/app/app.routes.ts'), `{path: '', loadChildren: () => import('./remote-entry/entry.routes').then(m => m.remoteRoutes)}`);
    }
    else {
        if (routing) {
            (0, route_utils_1.addRoute)(tree, (0, devkit_1.joinPathFragments)(appRoot, 'src/app/app.routes.ts'), `{path: '', loadChildren: () => import('./remote-entry/entry.module').then(m => m.RemoteEntryModule)}`);
        }
        tree.write(`${appRoot}/src/app/app.module.ts`, `/* 
      * This RemoteEntryModule is imported here to allow TS to find the Module during 
      * compilation, allowing it to be included in the built bundle. This is required 
      * for the Module Federation Plugin to expose the Module correctly.
      * */
      import { RemoteEntryModule } from './remote-entry/entry.module';
${tree.read(`${appRoot}/src/app/app.module.ts`, 'utf-8')}`);
    }
}
exports.addRemoteEntry = addRemoteEntry;
//# sourceMappingURL=add-remote-entry.js.map