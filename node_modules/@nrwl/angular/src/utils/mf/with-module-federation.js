"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.withModuleFederation = void 0;
const tslib_1 = require("tslib");
const utils_1 = require("./utils");
const project_graph_1 = require("nx/src/project-graph/project-graph");
const ModuleFederationPlugin = require("webpack/lib/container/ModuleFederationPlugin");
function determineRemoteUrl(remote) {
    const remoteProjectConfiguration = (0, project_graph_1.readCachedProjectConfiguration)(remote);
    let publicHost = '';
    try {
        publicHost = remoteProjectConfiguration.targets.serve.options.publicHost;
    }
    catch (error) {
        throw new Error(`Cannot automatically determine URL of remote (${remote}). Looked for property "publicHost" in the project's "serve" target.\n
      You can also use the tuple syntax in your webpack config to configure your remotes. e.g. \`remotes: [['remote1', 'http://localhost:4201']]\``);
    }
    return `${publicHost.endsWith('/') ? publicHost.slice(0, -1) : publicHost}/remoteEntry.mjs`;
}
function withModuleFederation(options) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const { sharedLibraries, sharedDependencies, mappedRemotes } = yield (0, utils_1.getModuleFederationConfig)(options, determineRemoteUrl);
        return (config) => {
            var _a, _b, _c, _d, _e, _f, _g;
            return (Object.assign(Object.assign({}, (config !== null && config !== void 0 ? config : {})), { output: Object.assign(Object.assign({}, ((_a = config.output) !== null && _a !== void 0 ? _a : {})), { uniqueName: options.name, publicPath: 'auto' }), optimization: Object.assign(Object.assign({}, ((_b = config.optimization) !== null && _b !== void 0 ? _b : {})), { runtimeChunk: false }), resolve: Object.assign(Object.assign({}, ((_c = config.resolve) !== null && _c !== void 0 ? _c : {})), { alias: Object.assign(Object.assign({}, ((_e = (_d = config.resolve) === null || _d === void 0 ? void 0 : _d.alias) !== null && _e !== void 0 ? _e : {})), sharedLibraries.getAliases()) }), experiments: Object.assign(Object.assign({}, ((_f = config.experiments) !== null && _f !== void 0 ? _f : {})), { outputModule: true }), plugins: [
                    ...((_g = config.plugins) !== null && _g !== void 0 ? _g : []),
                    new ModuleFederationPlugin({
                        name: options.name,
                        filename: 'remoteEntry.mjs',
                        exposes: options.exposes,
                        remotes: mappedRemotes,
                        shared: Object.assign({}, sharedDependencies),
                        library: {
                            type: 'module',
                        },
                    }),
                    sharedLibraries.getReplacementPlugin(),
                ] }));
        };
    });
}
exports.withModuleFederation = withModuleFederation;
//# sourceMappingURL=with-module-federation.js.map